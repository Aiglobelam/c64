My notes for Machine Language for the Commodore 64 and other Commodore computers by Jim Butterfield

Q: How much mem does the C64 have?
A: 64K
Q: What?
A: 64 KB or KBytes OR (K)ilo (B)ytes
Q: What is a byte?
A: 8 bits
Q: So 1 kilobyte is 1000 times 8 bits 8000 bits?
A: Nah... in this case.... its around that... and it is with capital K and B, KB not kb
   1024 bytes is 1KB, binary you see, 2^10 = 2*2*2*2*2 * 2*2*2*2*2 = 1024 bits
   1KB * 64 = 1024 bytes * 64 = 65536 bytes
   65536 * 8 = 524288 bits
Q: The address bus in C64 it is 16 bits... what does that mean?
A: 16 bits can be represented by HEX values $0000-$FFFF
   In this case that is a total  0 - 65536 addresses.
   At each of these 65536 addressess there can be 8 bits, that is 1 byte stored
   1 Byte aka 8 bits in HEX $00-$FF
Q: A I see so the 64 in this case comes from 65536 / 1024 = 64 => Commodore 64 => C64

Commodore 64 Microprocessor: 6510

650x - The Bus (Memory busses)

Control bus: ... The address bus is accompanied by a few extra wires... control things as read/write/timing...
Address bus: 16 bits $0000-$FFFF <=> 00000000 00000000 - 11111111 11111111 <=> 0 - 65536 "65536 different voltages"
Data    bus:  8 bits   $00-$FF   <=>          00000000 -          11111111 <=> 0 -   256 "  256 different voltages"

Microprocessor sends out a call to a memory chip at adddress $0400
It sends out voltages on 16 physical wires, the "Address bus"
All memory chips reads the address and knows if the call was made for it.
The selected memory chip answers.
Data is then sent to/from microprocessor and selected memory chip using the "Data bus"
It can be of type read/write.

Using the "Address bus" we can reach

	RAM: Random Access Memory, here we store programs, read/write

	ROM: Read Only Memory, read ONLY, fixed routines, fixed stuff

	IA:  Interface Adaptor, "memory mapped devices" 
             ex: IO, Timing devices, Interupt control systems, video controll, sound controll
	     
Address split in 2 parts "roughly"

	* HIGH: Selects specific chip
	* LOW: Selects particular memory from selected chip
	
Microprocessor Registers

	PC:    Program Counter, 16 bit, where should next instruction come from?
	A,X,Y: Hold data, 8 bits
	SR:    Status Register, aka PSW Processor Status Word, contain results of actions of data handling
	SP:    Stack Pointer, Keeps track of a temporary storage area
	
Instruction Execution

	1 PC reads from address bus address $1234 (if PC currently was executing from that address...)
	2 Processor increment PC by 1, $1235
	3 Information comes in from $1234
	4 That information will be taken as an "instruction"
	5 Processor has the instruction, which tells it to do something, processor do action
	6 repeat GOTO 1
	

MLM = Machine Language Monitor
Supermon by Jim Butterfield => "MLM generator"
Instructions:

	R => Display / Change registers
	M => Display / Change memory
	S => Save memory to disk or tape
	L => Load from disk or tape
	G => Go to an machine language program
	X => Exit to basic
	A => Assemble
	D => Disassemble
	F => Fill memory with fixed contents
	H => Hunts for a memory pattern
	T => Transfers a block of memory to a new location

page 14: START MLM => SYS 8

LDA $0380
LDX $0381
STA $0381
STX $0380

16^1 = 16
16^2 = 256
16^3 = 4096
16^4 = 65536
16^5 = 1 048 576

dec 173 => HEX
173 / 16 = 10.8125 (10 => A)
10*16 = 160
173-160 = 13 = D

	BINARY		HEX	DEC
LDA 	%10101101 	AD	128+32+8+4+1 = 173	A=10 D=13
         1010 => 128 + 0 + 32 + 0
             1101 => 8   + 4 + 0  + 1 

Machine code	Assembly code
AD 80 03	LDA $0380

AD => Operation Code aka op-code
   => Occupies 1 BYTE of memory

$0380 => Opperand
      => Address, 16 Bits long, 2 BYTE of memory
80 03 => CRUX last BYTE (80) comes first in machine code… and then (03)
      => Called “Low Byte First” storing address standard in 650x processor.

MACHINE LANGUAGE OP-CODES AND ASSEMBLY MNEMONICS
LDA => AD	LDX => AE	LDY => AC	BRK => 00
STA => 8D	STX => 8E	STY => 8C

=====================================================
==== PROGRAM FÖR ATT BYTA PLATS PÅ 2 VÄRDEN I MINNET

Machine Code	Assembly Code
(Object Code)	(Source Code)
- - - - - - 	- - - - - - -
AD 80 03	LDA $0380	Ladda a-register med värdet på adress $0380
AE 81 03	LDX $0381	Ladda x-register med värdet på adress $0381
8D 81 03	STA $0381	Skriv värdet i a-register till adress $0381
8E 80 03	STX $0380	Skriv värdet i x-register till adress $0380
00		BRK

Program is 13 BYTE long
AD 80 03 AE 81 03 8D 81 03 8E 80 03 00
1  2  3  4  5  6  7  8  9  10 11 12 13

==========================
== Place program into ram

Address $033C => “Cassette buffer”

   0    3    3    C
0000 0011 0011 1100
      768   48   12 = 828	

Put each instruction at a mem location

		Machine Code	Assembly Code
Address		(Object Code)	(Source Code)
- - - - - - -	- - - - - - 	- - - - - - -
033C AD 80 04	AD 80 03	LDA $0380	3 BYTE => 033C=1 033D=2 033E=3 NEXT=>033F
033F AE 81 03	AE 81 03	LDX $0381	3 BYTE => 033F=1 0340=2 0341=3 NEXT=>0342
0342 8D 81 03	8D 81 03	STA $0381	3 BYTE => 0342,0343,0344       NEXT=>0345
0345 8E 80 03	8E 80 03	STX $0380	3 BYTE => 0345,0346,0347       NEXT=>0348
0348 00		BRK

=================
== Screen memory

C64 => $0400 and upwards

   0  4      0    0
0000 0100 0000 0000
   0 + 1024 + 0 + 0 = 1024

=============
= Subroutines

JSR => Jump subroutine
RTS => Return subroutine

* Prewritten subroutines (Kernal subroutines)
- Stored in ROM
- KERNAL (K)eyboard (E)ntry (R)ead (N)etwork (A)nd (L)ink
- KERNAL Operating systemmake screen, keyboard, I/O and control mechanism work together.

Dec	Binary	Address	 Name	
- - - -|- - - |-- - - -| - - -
65490		$FFD2	 CHROUT	Output an ASCII char from A-reg to Screen/Disk/Cassette/Tape/Device X
		$FFE4	 GETIN	Gets an ASCII char
		$FFE1	 STOP	Checks the RUN/STOP key

ASCII letters
X = $58				
RETURN = $0D
CLS = $93
A $41	B $42	C $43	D $44	E $45
F $46	G $47	H $48	I $49	J $4A
K $4B	L $4C	M $4D	N $4E	O $4F
P $50	Q $51	R $52	S $53	T $54
U $55	V $56	W $57	X $58	Y $59
Z $5A

# => Immediate addressing

LDA #$48 	Load value 48 into A-reg
JSR $FFD2	Invoke Kernal SubRoutine CHROUT, Print “H” to screen

===============================
== ASSEMBLE (Supermon command)
Instead of “hand assembling” use the ASSEMBLE Monitor command (A)

A 033C LDA #$48 => Becomes

A 033C A9 48	LDA #$48
A 033E

Adding more code

A 033C A9 48	=> LDA #$48	2 BYTES 033C,033D
A 033E 20 D2 FF => JSR $FFD2	3 BYTES 033E,033F,0340
A 0341 00       => BRK		1 BYTE  0341
A 0342

Press enter to quit assembler command

G 033C => Prints “H” where cursor are placed

A 0337 A9 0D	=> LDA #$0D “Return/NewLine”
A 0339 20 D2 FF => JSR $FFD2 	3 BYTES	0339,033A,033C => CHROUT A-reg “new line”
A 033C A9 48	=> LDA #$48	2 BYTES 033C,033D
A 033E 20 D2 FF => JSR $FFD2	3 BYTES 033E,033F,0340 => CHROUT A-reg “H”
A 0341 A9 49	=> LDA #$48	2 BYTES 0341,0342 
A 0343 20 D2 FF => JSR $FFD2	3 BYTES 0343,0344,0345 => CHROUT A-reg “I”

G 0337 => Prints HI on a new line

=================================
== DISASSEMBLE (Supermon command)
(D) go from code in memory to “Assembly / Source code”
D 033C

======================
== Linking with BASIC

Link to machine language program from BASIC
When machine language program is finished return to BASIC

BASIC => SYS “address” => Go to machine language subroutine at address
ML    => RTS           => Return to caller

Change BRK to RTS => A 0346 RTS
List using disassembler => D 0337 0346

A 0337 A9 0D	=> LDA #$0D “Return/NewLine”
A 0339 20 D2 FF => JSR $FFD2 	3 BYTES	0339,033A,033C => CHROUT “new line”
A 033C A9 48	=> LDA #$48	2 BYTES 033C,033D
A 033E 20 D2 FF => JSR $FFD2	3 BYTES 033E,033F,0340 => CHROUT “H”
A 0341 A9 49	=> LDA #$48	2 BYTES 0341,0342 
A 0343 20 D2 FF => JSR $FFD2	3 BYTES 0343,0344,0345 => CHROUT “I”
A 0346 60       => RTS		1 BYTE  0346 => Return to invoker of routine…


Type X to exit into BASIC

HEX => 0337
BIN => 0000 0011 0011 0111
DEC =>    0  768   48    7 => 823

SYS 823 => Call subroutine at adress 0337 => Print “HI” on new line

To call a subroutine starting at adress 033C
SYS 828 => Call subroutine at adress 033C

=================
== LOOPS

a 033C LDX #$00    => 2 BYTES Immediate addressing => value 0 in x-reg, treat X as counter
a 033E LDA $034A,X => 3 BYTES 033E, 033F, 0340 Load A-reg with value at $034A + x (0-5) 
		   => $034A + 0 = $034A
		   => $034A + 1 = $034B
		   => $034A + 2 = $034C
		   => $034A + 3 = $034D
		   => $034A + 4 = $034E
a 0341 JSR $FFD2   => 3 BYTES 0341, 0342, 0343 => CHROUT value in A-reg
a 0344 INX         => 1 BYTE INCREMENT VALUE IN X-REG WITH 1
a 0345 CPX #$06    => 2 BYTES 0345, 0346 => Compare X-reg with value 6
a 0347 BNE $033E   => 2 BYTES 0347, 0348 => check status reg with latest comparison
		   => branch to address $033E if X-reg != 6
a 0349 RTS         => We are done, x are equal to 6, return to invoker of this subroutine

To insert data into memory use the (Supermon command) (M) command
M 034A 034F => List memory content, move cursor type in new value, press enter to "save"

Adress	034A 034B 034C 034D 034E
char	H    E    L    L    O
Hex	48   45   4C   4C   4F   

(Supermon command) “x” => return to BASIC
x => return to BASIC

our program starts at address 033C => 0000 0011 0011 1100 => 828 decimal

SYS 828

To call a subroutine starting at adress 0342

033C 828
033D 829
033E 830
033F 831
0340 832
0341 833
0342 834

SYS 834 => Call subroutine at adress 0342

===================
== A Stop gap save
Preserving short programs in BASIC “DATA” statements

1) Get program data out of memory as decimals
FOR J=828 to 847:PRINT PEEK(J);:NEXT J

2) Outputs the memory in decimal format, our program =)
162 0 189 74 3 32 210 255 232
224 6 208 245 96 72 69 76 76 79
                 H  E  L  L  O

Below doesn’t seem to work might work later on when i look at it…
50 data 162 0 189 74 3 32 210 255 232
60 data 224 6 208 245 96 72 69 76 76 79
80 for j=828 to 847: read x:poke j,x:next j
100 for j=1 to 3
110 sys 828
120 next j


#############
# CHAPTER 3 #
#############

==============
= Interrupts

Computer “freezes” 60 times / second => Interrupt processing
Stops what it is doing
Switch to a new set of programs
* Flasing the cursor
* Checking the keyboard
* Keep clock up to date
* cassette motor needs power?
Finished “unfreezes” and continue what it was doing

=========
= Flags

650X Reference manual show what flags are affected by which instruction

a 0345 CPX #$06    => 2 BYTES 0345, 0346 => Compare X-reg with value 6
a 0347 BNE $033E   => 2 BYTES 0347, 0348 => check status reg with latest comparison

CPX and BNE interlinked by flags, that notes if something has happened.

CPX “test” X and set flag to signal how the comparison turned out.

BNE depends on that flag

=> Some instructions leave a trail of status information in the form of flags
=> Other instructions depend on those flags

Z => Zero 
  => (The EQUAL flag) CPX,CPY,CMP(the a-reg), Z=1 if comparison is EQUAL
  => Sometime checks for EQUAL to ZERO => Z will be set to 1 (ex using LDX #$00)
  => Z-flag set by any activity that may change the data registers X,Y,A
  => ex LDA, LDX  might change Z flag.
  => STA, STX, STY does not change any flag including the Z flag.

C => Carry
  => (The GE Greater/Equal flag) 
  => Ex) CPX,CPY,CMP, C=1 if X,Y,A is greater or equal to compared value.
  => C-flag only affected by comparison, arithmetic
  => BCS, Branch Carry Set   => C=1 => Do branch
  => BCC, Branch Carry Clear => C=0 => Do branch
  => SEC, Set Carry
  => CLC, Clear Carry

N => Negative
  => (HB, the High Bit)
  => The N flag is set to indicate that a register has been given a value whose HB is set
  => Affected by instructions that affects an register ex X,Y,A
  => Affected by comparison
  => BMI, Branch Minus, N=1 => Do branch
  => BPL, Branch Plus,  N=0 => Do branch

V => Overflow
  => (The SAO flag, the signed arithmetic overflow)
  => Affected by addition and subtraction instructions.
  => Meaningfull only if numbers dealt with are concerned to be signed
  => BIT, Bit Test, V flag signals the condition of bit 6 of the tested memory location.
  => Z-flag is bit 7, V-flag is bit 6
  => BIT command primary usage tetst I/O ports on a IA (I)nterface (A)daptor
  => BVS, Branch Overflow Set,   V=1 => Do branch
  => BVC, Branch Overflow Clear, V=0 => Do branch
  => CLV, Clear Overflow, set V to 0
  => On some 650X chips the V-flag can be set by hardware, there is a pin on that chip
     that can be used so that an external logic signal will trigger the V-flag
 
=================
= Singed numbers

   0->+255 unsigned
-128->+127   signed “Twos complement form”

-1	FF 	1111 1111
-2   	FE 	1111 1110
. . .
-128	80	1000 0000

EX) Load A-reg with value decimal 200, C8, 1100 0000
LDA #$C8 => As we can se the N flag is set because the first digit is set in “1100 0000”

200 is a negative number, if we want it to be a negative number

Count down from hex 10
16 $10 0001 0000 HB is NOT set
15 $0F 0000 1111 HB is NOT set
14 $0E 0000 1110 HB is NOT set
13 $0D 0000 1101 HB is NOT set
12 $0C 0000 1100 HB is NOT set
11 $0B 0000 1011 HB is NOT set
10 $0A 0000 1010 HB is NOT set
 9 $09 0000 1001 HB is NOT set
 8 $08 0000 1000 HB is NOT set
 7 $07 0000 0111 HB is NOT set
 6 $06 0000 0110 HB is NOT set
 5 $05 0000 0101 HB is NOT set
 4 $04 0000 0100 HB is NOT set
 3 $03 0000 0011 HB is NOT set
 2 $02 0000 0010 HB is NOT set
 1 $01 0000 0001 HB is NOT set
 0 $00 0000 0000 HB is NOT set
-1 $FF 1111 1111 (-128 +64+32+16+8+4+2+1) HB is set
-2 $FE 1111 1110 (-128 +64+32+16+8+4+2  ) HB is set
-3 $FD 1111 1101 (-128 +64+32+16+8+4  +1) HB is set
-4 $FC 1111 1100 (-128 +64+32+16+8+4    ) HB is set 

================
= Overflow
The result is to big to fit!!!

ex) 200 + 200 is 400 and 255 is the largest value that fits into a BYTE…
1   1  1  1   1 1 1 1
128+64+32+16 + 8+4+2+1 = 255
FF

If we are using UNSIGNED numbers C-flag tells us about OVERFLOW
If we are using   SIGNED numbers V-flag tells us about OVERFLOW

===================
= More flags

(Supermon command) (R) => shows all registers in supermon

	PC	SR	AC 	XR 	YR 	SP
;	000A	33	00	06	00	F6

SR => The (S)tatus (R)egister
SR => HEX 33 => BIN 	0 0 1 1   0 0 1 1
			N V - B   D I Z C
			* *           * *
Bit number		7 6 5 4   3 2 1 0

====================
= Not testable flags

B => WHEN an INTERRUPT occur, B-flag indicates if a BRK op code caused the INTERRUPT
D => Decimal mode indicator, ADD/SUBTRACTION behaviour, C64 default to OFF 
  => SED, set decimal
  => CLD, clear decimal
I => Interrupt disable, I-flag disables the interrupt request pin activity
  => SEI, Set interrupt disable
  => CLD, Clear interrupt disable

=====================
= Flag summary table

Bit	| Flag	  Brief		 Activity	 Branch Taken if:
Number	| Name	  Meaning	 Level		 Set	Not-Set
- - - -	|- - - -| - - - - - - - | - - - - - - - | - - - - - - - - -
7 *	| N	| Neg, high bit	| Busy		| BMI	BPL
6 *	| V	| Signed arithm | Quiet		| BVS	BVC
	|	| overflow	| 
5	| -	| Not used	|
4	| B	| Interrupt	|
	|	| caused by BRK |
3	| D	| decimal	|
2	| I	| Interrupt dis |
1 *	| Z     | Zero,  n == x	| Buy		| BEQ	BNE
0 *	| C	| Carry, n >= x	| Quiet		| BCS	BCC

=============
= Comparison

After for a comparison using for ex CPX,CPY,CMP

BEQ : == : Branch if two BYTES are EQUAL
BNE : != : Branch if two BYTES are NOT EQUAL
BCS : >= : reg >= value => Branch if register value are greater than or equal to value
BCC : <  : reg <  value => Branch if register value are less than

====================
= Logical Operators

Only works on A-reg, Each bit is treated INDEPENDENT

AND : Logical AND  : turns bits off
ORA : Logical OR   : turns bits on
EOR : Exclusive OR : flip  bits over

- - - -
| AND | 1 => Keep Origin, 0 => Turn Bit OFF
- - - -
A-Reg	Mask	Mask Meaning	Result
0	0	Turn Bit OFF 	0	
1	0	Turn Bit OFF 	0
0	1	Keep origin	0	
1	1	Keep origin	1	

- - - -
| ORA | 1 => Turn Bit On, 0 => Keep Origin
- - - -
A-Reg	Mask	Mask Meaning	Result
0	0	Keep origin	0
1	0	Keep origin	1
0	1	Turn Bit ON	1
1	1	Turn Bit ON	1

- - - -
| EOR | 1 => Flip bit, 0 => Keep Origin
- - - -
A-Reg	Mask	Mask Meaning	Result
0	0	Keep origin	0
1	0	Keep origin	1
0	1	Flip Bit	1
1	1	Flip Bit	0

================================
= When to use LOGICAL operators?

AND, ORA, EOR used when dealing with 

1) IA (I)nterface (A)daptor controlling external devices.

2) Code Translation

Examples)

5:ASCII 0011 0101 : Used for input or output to scrren the ASCII char “5”
5:Bin	0000 0101 : Use the VALUE 5 when doing arithmetics

ASCII   0011 0101 => Convert this ASCII 5 char to its binary value
  AND   1100 1111 => Keep value of bits that we have masked with 1
RESULT  0000 0101 => 5 binary / decimal value to be used in arithmetic

BINARY  0000 0101 => Convert this binary value 5 to ascii
   ORA  0011 0000 => Turn bits on that are masked with 1, 0 keep original
RESULT  0011 0101 => The ascii 5 char

==============================
= INPUT: The GETIN Subroutine

* Prewritten subroutines (Kernal subroutines)
- Stored in ROM
- KERNAL (K)eyboard (E)ntry (R)ead (N)etwork (A)nd (L)ink
- KERNAL Operating systemmake screen, keyboard, I/O and control mechanism work together.

Address	 Name	
- - - -  - - -
$FFD2	 CHROUT	Output an ASCII char from A-reg to Screen/Disk/Cassette/Tape/Device X
$FFE4	 GETIN	Gets an ASCII char
$FFE1	 STOP	Checks the RUN/STOP key

- - - - -
| GETIN |
- - - - -
+ $FFE4
+ Gets an ASCII char from the keyboard buffer
+ Input is taken from the keyboard buffer NOT the screen
+ If a key is HELD DOWN => Still only one detection
+ This subroutine returns immediately
+ If no key is found, a binary zero is returned in A-reg
+ If a key is found, its ASCII value will be in A
+ Special keys RETURN, RVS, color codes will also be detected (What???)

OBS: A JSR to $FFE4 does not guarantee that X-reg and Y-reg values are the same as before.

OBS: Does not wait for a key to be pressed, just looks in the buffer if it has been.

OBS: If we want the keyboard input to appear on screen we should follow a call to 
GETIN with a call to CHROUT.


=================
= STOP

Machine language programs ignore the RUN/STOP button (unless the program itself does not check for it.

- - - - -
| STOP |
- - - - -
+ $FFE1
+ Checks the run/stop key at that very moment
+ BEQ branch to “EXIT” should follow a STOP so that program is terminated
+ Useful to have in code while one is TESTING the code

OBS - To make the key operational it must be called frequently…

+ SR-register flag Z signals when RUN/STOP is being pressed, bit number 1 => XXX XX(1)X

#######################
# Programming project #
#######################

BEQ : == : Branch if two BYTES are EQUAL
BNE : != : Branch if two BYTES are NOT EQUAL
BCS : >= : reg >= value => Branch if register value are greater than or equal to value
BCC : < : reg < value => Branch if register value are less than to value

Numeric KEYs, RUN/STOP
Numeric key => Echo to screen

ASCII TABLE page 215
/ : $2F   
0 : $30	: 0011 0000
1 : $31 : 0011 0001
2 : $32 : 0011 0010
3 : $33 : 0011 0011
4 : $34 : 0011 0100
5 : $35 : 0011 0101
6 : $36 : 0011 0110
7 : $37 : 0011 0111
8 : $38 : 0011 1000
9 : $39 : 0011 1001

as we se the 4 most highbits are the same for 0-9 in ascii and the low 4 is the actual value of the ASCII char…. cool

.a 033c jsr $ffe1	=> check RUN/STOP key, 3 BYTES 033C, 033D, 033E
.a 033f BEQ !!!! $0351, => 2 BYTES 033F, 0340
.a 0341 jsr $ffe4	=> GETIN, sets ASCII char in A-reg, or 0 in A-reg if not found
.a 0344 cmp #$30	=> Compare value in A-reg with ascii “0” aka #$30 (immediate addr)
.a 0346	BCC $033c	=> Branch if A-reg was < #$30, then branch to $033C
.a 0348 cmp #$3A	=> Compare value in A-reg is larger than dec 40 => hex 3A
.a 034a BCS $033c	=> Branch back to input reading if larger or equal

// We now have an ascii char i A-reg, lets print char to screen
// $FFD2 : CHROUT : Output an ASCII char from A-reg to Screen/Disk/Cassette/Tape/Device X

.a 034c jsr $ffd2	=> Jump to kernel subroutine CHROUT to print to screen from A-reg

// convert ascii to binary, turn HIGH bits off using AND

.a 034f AND #$0F 	=> 0F = 0000 1111  (Just for fun has nothin to do with routine)
			   Performs a logical AND to shut down the 4 high bits and keep the 4 low
.a 0351 RTS		=>

###########################
## Questions and Projects #
###########################

Project enthusiasts

1) Rewrite so to use ALPHA chars #$41 to #$5A

2) Write extra coding to allow both numeric (#$30 to #$39) and alpha (#$41 to #$5A)

BEQ : == : Branch if two BYTES are EQUAL
BNE : != : Branch if two BYTES are NOT EQUAL
BCS : >= : reg >= value => Branch if register value are greater than or equal to value
BCC : < : reg < value => Branch if register value are less than value

.a 033c jsr $ffe1	=> check RUN/STOP key, 3 BYTES 033C, 033D, 033E
.a 033f BEQ !!!! $0359, => 2 BYTES 033F, 0340
.a 0341 jsr $ffe4	=> GETIN, sets ASCII char in A-reg, or 0 in A-reg if not found

.a 0344 cmp #$30	=> Compare A-reg value with ascii “0” aka #$30 (immediate addr)
                           If A-reg value is            equal to #$30 => SR z-flag (zero flag)  is set to 1
			   If A-reg value is greater or equal to #$30 => SR c-flag (carry flag) is set to 1
			   
.a 0346	BCC $033c	=> BCC, Branch Carry Clear. If c-flag = 0 Do branch
                           If A-reg was < #$30, then branch to begining of program $033C else continue
			   
.a 0348 cmp #$3A	=> Compare value in A-reg is greater or equal #$3A decimal 58 ":" char after "9"
                           If we got a char on or after ":" c-flag is set to 1
			   
.a 034a BCC $0354	=> BCC, Branch Carry Clear. If c-flag = 0 Do branch
                           If we have a 0 in c-flag it means that we got something in a-reg less than ":"
                           Branch forward to CHROUT command to print to screen because we found 0-9
			   Else continue to search for "alpha letters"

.a 034c cmp #$41	=> Compare value in A-reg with ascii “A” aka #$41 (immidiate adds)
.a 034e BCC $033c	=> Start over from $033c if value < #$41
.a 0350 cmp #$5B	=> Do a comparison again with char value for “Z”
.a 0352 BCS $033c	=> Start over from $033c if value >= “Z” hmmmm

.a 0354 jsr $ffd2	=> Jump to kernel subroutine CHROUT to print to screen from A-reg
.a 0357 RTS

ASCII CHAR TABLE page 215

+ : $2B :           : 43
´ : $2C :           : 44
- : $2D :           : 45
  : $2E :           : 46
/ : $2F :           : 47
0 : $30	: 0011 0000 : 48
1 : $31 : 0011 0001 : 49
2 : $32 : 0011 0010 : 50
3 : $33 : 0011 0011 : 51
4 : $34 : 0011 0100 : 52
5 : $35 : 0011 0101 : 53
6 : $36 : 0011 0110 : 54
7 : $37 : 0011 0111 : 55
8 : $38 : 0011 1000 : 56
9 : $39 : 0011 1001 : 57
: : $3A : 0011 1010 : 58
; : $3B : 0011 1011 : 59
< : $3C :           : 60
= : $3D :           : 61
> : $3E :           : 62
? : $3F :           : 63
@ : $40 : 0100 0000 : 64
A : $41 : 0100 0001 : 65 = 64 + 1
B : $42 : 0100 0010 : 66
C : $43 : 01        : 67
D : $44 : 01        : 68
E : $45 : 01        : 69
F : $46 :           : 70
G : $47 :           : 71
H : $48 :           : 72
I : $49 :           : 73
J : $4A :           : 74
K : $4B :           : 75
L : $4C :           : 76
M : $4D :           : 77
N : $4E :           : 78
O : $4F :           : 79
P : $50 :           : 80
Q : $51 :           : 81
R : $52 :           : 82
S : $53 :           : 83
T : $54 :           : 84
U : $55 :           : 85
V : $56 :           : 86
W : $57 :           : 87
X : $58 :           : 88
Y : $59 :           : 89
Z : $5A : 0101 1010 : 90 = 64 + 16 + 8 + 2
[ : $5B :           : 91

#############
# CHAPTER 4 #
#############

Numbers Arithmetic and Subroutines,
It makes no difference to the computer, its up to you to handle them numbers as signed or not…

===============================
= Numbers: Signed and Unsigned

Signed -128 to +127, at most significant bit in byte 1 = neg / 0 = positive

(-128) 1 1 1 …     1 0 0 0 0 … 0
(+ 64) 0 0 0 …     1 0 0 0 0 … 1
(+ 32) 0 0 0 …     1 0 0 0 0 … 1
(+ 16) 0 0 0 …     1 0 0 0 0 … 1
(+  8) 0 0 0 …     1 0 0 0 0 … 1
(+  4) 0 0 0 …     1 0 0 0 0 … 1
(+  2) 0 0 1 …     1 0 0 1 1 … 1
(+  1) 0 1 0 …     1 0 1 0 1 … 1 

-128,-127,-126,…, -1,0,1,2,3,…, 127  

============================
= Big Numbers Multiple bytes

When expressing numbers with multiple bytes, and they are thought of as signed,
only the highest bytes highest bit is the sign bit.

        | unsigned  | signed 
- - - - | - - - - - | - - - - - - - - -
1 byte  | 0-255     |     -128 to +127
2 bytes | 0-65535   |   -32768 to +32767
3 bytes | 0-16777212| -8388608 to +8388607
4 bytes | 0-4billion| -2billion to +2billion

===========
= Addition

1) CLC Set carry (C-flag) bit to 0
2) Addition takes place in A-reg
   If multiple byte numbers are used start at the lowest bytes adding them together.
   The carry flag will be set if the number becomes to big to store in one byte.
   Continue on with next bytes until all are added.
3) If number is thought of as 

	UNSIGNED C-flag==1 indicates overflow
	  SIGNED V-flag==1 indicates overflow

4) BCS if overflow to other subroutine handling the error perhaps
   
==============
= Subtraction

“UpSideDown” addition

C-flag, now called “Inverted borrow”

1) SEC Set C-flag to 1

2) Subtraction takes place in A-reg, byte per byte as in addition

3) If number is thought of as 

	UNSIGNED C-flag==0 indicates overflow
	  SIGNED V-flag==1 indicates overflow

===================
= Comparing numbers

CMP => Compare A-reg
CPX => Compare X-reg
CPY => Compare Y-reg

Then after using CMP, CPX or CPY check C-flag

BUT you can use subtraction!!!!!!!

Subtract one number from the other 

ex) N1 - N2 = N3

    If C-flag==1

	Then N1 > N2 OR N1 == N2
	WHY? => The subtraction was legal, we did not have to use the extra carry bit

    IF C-flag==0

	Then N1 <  N2
	“HY => The subtraction generated a negative number, which can not be represented in Unsigned arithmetic

==================================
= Left shift, multiplication by 2

Dec	Bin
100	%0110 0100
200	%1100 1000

Conclusion to double the number move each BIT a position to the left and fill with 0 from the right

=> ASL: Arithmetic Shift Left

	* The left most bit is moved to the Carry, C-flag
		- 0 to carry ok
		- 1 to carry… OVERFLOW

Multiple bytes

=> ROL: Rotate Left

	* The current value of Carry, C-flag 0 or 1 is pushed into the right most bit
	* The left most bit is moved to the Carry
	=> We can hook together 2 Bytes

		1) CLC Clear Carry to set it to 0 
		BYTE-1   BYTE-2
		01001000 11001000
			 ROL BYTE 2
		         (1)1001000(0) The previous carry
			  |
			  |_New Carry

		ROL BYTE-1
		(0)100100(1)- Carry brought from previous ROL
                 |
		 |_New Carry (great we did not get overflow… because a ZERO was pushed into the C-flag)

=================
= Multiplication

Multiplication by using “Multiply by 2”

Multiply by 4 => “Multiply by 2” TWICE

Multiply by 8 => “Multiply by 2” THREE TIMES

Multiply by 10 => “Multiply by 2” TWICE, ADD Original number, “Multiply by 2”

==========================================
= Dividing by two, Right Shift and Rotate

Move the bits the other way around compared with mult by 2.

LSR = Logical Shift Right

	* Puts ZERO into the left most bit
	* Move other bits to left one step
	* The right most bit falls in to C-flag, the Carry

ROR = Rotate Right

	* Puts Carry-bit C-flag bit, into the rightmost bit
	* moves other bits to the right
	* The right most bit falls into carry

The final carry bit at the end of right shifting might be considered the “Remainder” after dividing

===============================
= Comments on Shift and rotate
SHIFT and ROTATE instruction operates on A-reg and directly on memory addresses.

Book states this when it comes to “Logical” VS “Arithmetic”
Logical    => Sign of a number will probably be lost if the num was intended to be signed.
Arithmetic => Sign will probably be resereved

==============
= The Project

.a 033c jsr $ffe1	=> check RUN/STOP key, 3 BYTES 033C, 033D, 033E
.a 033f BEQ $0351	=> 2 BYTES 033F, 0340 Branch to our RTS statement bellow if Runstop key was pressed
.a 0341 jsr $ffe4	=> GETIN, sets ASCII char in A-reg, or 0 in A-reg if not found
.a 0344 cmp #$30	=> Compare value in A-reg with ascii “0” aka #$30 (immediate addr)
.a 0346	BCC $033c	=> Branch if A-reg was < #$30, then branch to $033C
.a 0348 cmp #$3A	=> Compare value in A-reg is larger than dec 40 => hex 3A (char after “9”)
.a 034a BCS $033c	=> Branch back to input reading if larger or equal

// We now have an ascii char i A-reg, lets print char to screen
// $FFD2 : CHROUT : Output an ASCII char from A-reg to Screen/Disk/Cassette/Tape/Device X

.a 034c jsr $ffd2	=> Jump to kernel subroutine CHROUT to print to screen from A-reg

// convert ascii to binary, turn HIGH bits off using AND

.a 034f AND #$0F 	=> 0F = 0000 1111  (Just for fun has nothin to do with routine)
			   Performs a logical AND to shut down the 4 high bits and keep the 4 low
.a 0351 RTS		=>

************************
*** Addition program ***
************************

.a 0352 JSR $033C => Jump to routine above starting at $033C, read 0-9 char and put into A-reg
.a 0355 STA $03C0 => Store the value in A-reg at addr  $03C0
.a 0358 LDA #$2B  => Store the char “+” in A-reg
.a 035A JSR $FFD2 => Print value in A-reg to screen
.a 035D JSR $033C => Jump to input reading subroutine again. and get a new figure

.a 0360 TAX       => Copy value in A-reg to X-reg
.a 0361 LDA #$3D  => Store the value of “=“ at A-reg
.a 0363 JSR $FFD2 => jsr to chrout to put “=“ char at screen

.a 0366 TXA       => copy back the second input digit into a-reg
.a 0367 CLC       => Clear cary, set it to 0, remember addition put into carry if addition to big
.a 0368 ADC $03C0 => Addition, with value in A-reg and value at adds $033C
                  => we now have the sum in the A-reg of the addition
                  => The value is in BINARY FORM we have to transform it to decimal!
		  => if result is < 9 we can use ORA

.a 036B ORA #$30  =>    A: xxxx xxxx
                     #$30: 0011 0000
		      $30: 0011 0000 : 48 dec : char “0”

			If we look at char ascii table we we see that the 0-9 all starts with 0011 xxxx
			So I guess the ORA here is just to make sure the result in a-reg is mimicing
			this layout of 0s and 1s. And if we only allow us to add numbers that in total
			will just become at a max 9 this transformation with ORA will make the result
			be a char that we can output to the screen directly…
			“0” : $30 : 0011 0000
			“1” : $31 : 0011 0001
			“2” : $32 : 0011 0010
			“3” : $33 : 0011 0011
			“4” : $34 : 0011 0100
			“5” : $35 : 0011 0101
			“6” : $36 : 0011 0110
			“7” : $37 : 0011 0111
			“8” : $38 : 0011 1000
			“9” : $39 : 0011 1001

.a 036D JSR $FFD2 => ptrint to screen the transformed value
.a 0370 RTS       => return to invoker…

supermon command x => return to BASIC

Run the program from BASIC with “sys 850”

DEC 850
BIN xxxx xxxx xxxx xxxx
    0000 0011 0101 0010 
DEC       768   80    2
HEX     0   3    5    2 => and it is at adress $0352 our program starts
1) 850 - 768 = 82
2)  82 -  80 =  2
3)   2 -   2 =  0


ASCII CHAR TABLE page 215

+ : $2B :           : 43
´ : $2C :           : 44
- : $2D :           : 45
  : $2E :           : 46
/ : $2F :           : 47
0 : $30	: 0011 0000 : 48
1 : $31 : 0011 0001 : 49
2 : $32 : 0011 0010 : 50
3 : $33 : 0011 0011 : 51
4 : $34 : 0011 0100 : 52
5 : $35 : 0011 0101 : 53
6 : $36 : 0011 0110 : 54
7 : $37 : 0011 0111 : 55
8 : $38 : 0011 1000 : 56
9 : $39 : 0011 1001 : 57
: : $3A : 0011 1010 : 58
; : $3B : 0011 1011 : 59
< : $3C :           : 60
= : $3D :           : 61
> : $3E :           : 62
? : $3F :           : 63
@ : $40 : 0100 0000 : 64
A : $41 : 0100 0001 : 65 = 64 + 1
B : $42 : 0100 0010 : 66
C : $43 : 01        : 67
D : $44 : 01        : 68
E : $45 : 01        : 69
F : $46 :           : 70
G : $47 :           : 71
H : $48 :           : 72
I : $49 :           : 73
J : $4A :           : 74
K : $4B :           : 75
L : $4C :           : 76
M : $4D :           : 77
N : $4E :           : 78
O : $4F :           : 79
P : $50 :           : 80
Q : $51 :           : 81
R : $52 :           : 82
S : $53 :           : 83
T : $54 :           : 84
U : $55 :           : 85
V : $56 :           : 86
W : $57 :           : 87
X : $58 :           : 88
Y : $59 :           : 89
Z : $5A : 0101 1010 : 90 = 64 + 16 + 8 + 2
[ : $5B :           : 91

###########################
## Questions and Projects #
###########################

Write a program to subtract two single-digit numbers.

TODO: ...

#############
# CHAPTER 5 #
#############

Address modes

Computer instruction => "op code" && "address/operand"

Address mode => In which way does an instruction obtain information

13 address modes in 650x microprocessor

1) Implied Mode
   Needs no address, occupy only 1 byte in memory
   Ex) INX, BRK, TAY
   Ex) NOP, does nothing
   
2) Accumulator Mode
   Allow data manipulation in A-reg or memory without using address
   Using ASL, ROL, LSR, ROR
   Ex) ASL A (Accumulator Mode Addressing)
   Ex) ASL $0380 => NO NO NO this is not No Address Accumulator mode, here address is used.
   
3) Immediate Mode
   Ex) LDA #$38, Load register A with the value of $38, occupy 2bits in mem.
   
4) Absolute Mode
   Ex) JSR $03C0, go to address...

5) Zero-Page Mode
   All addresses from $0000 to $00FF
   Popular "Hard to find"
   Occupy less space and run slightly faster
   Often usefull information can be found at Zero-Paged addresses
   User holding down a key => $CB that is $00CB
   EX) LDA $90 instead of LDA $0090
   EX) LDA $F3 instead of LDA $00F3
   
6) Indexed Mode - Absolute
   - Give an absolute address and then indicate that the contents of X or Y 
     should be added to this address to give an "effective address"
   - Used only for data handling
   - Can reach up to 256 locations
   - Can be used to create loops
   Ex) LDA $034A,X => 3 BYTES 033E, 033F, 0340 Load A-reg with value at $034A + value at x-reg

7) Indexed Mode - Zero-Page
   Ex) LDA $E0,X (If X contains 50, the effective adddress will be $0030) WHAAAT!?!?!?
       
         $E0 hex =       1110 0000 binary = 224 decimal
       + $50 hex =       0101 0000 binary =  80 decimal
       -----------------------------------------------
       = $130 hex = 0001 0011 0000 binary = 304 decimal
       		    256 + 32+16 =304 decimal
       
       BECAUSE => Even though $E0 + $50 = 130, this will be trimmed to 30 and then 00 infront give $0030
       
8) Relative Address Mode - Branching
   Branching... assembler allow us to enter the actual addresss to which we want to branch
   Ex) BEQ $033C branch on equal to address $033C
   This is actually translated into a diffrent form of addressing... WHAT!!!!!???
   RELATIVE ADDRESS
   Translated to: Branch forward/backward a certain number of bytes from this point.
   How many steps/bytes to take is calculated like this: PC address - Target address
   1) PC current address, in this case $0343 (location after branch BEQ $033C instruction) (Hmmm not 0344?, 3 byte inst?)
   2) Subtract => $0341 - $033C = -7 decimal => hex signed $F9, (A-F 7 steps)
   	-7 $033C
	-6 $033D
	-5 $033E
	-4 $033F
	-3 $0340
	-2 $0341 BEQ $033C (isnt this a 3byte instruction?)
	-1 $0342
	 0 $0343

    CRUX
    In this case it worked well, just 7 steps...
    But in reality just 128 backwards and 127 forward steps can be made.
    
    Jens note: So I guess this one must have in mind when using branch instruciton? Not clear in text in book...?!?!?
    
    Instuction JMP can take you longer, to the exact address specified, JMP $65AC
    
9) Indirect Addressing Mode, ROM Link, JMP indirect

   Ex) JMP($1234) Which means that address $1234 will contain which address to actually jump to
   
   Within ROM, Read Only Memory, In ROM there exist indirect jmp's to addresses stored in RAM, Random Access Memory
   
   Ex) C64 => RAM $0314 Associated with interrupt sequences in ROM, so writing to $0341 we can fiddle with that.
   
10) Indirect ,Indexed Mode AKA Indirect Addressing Mode with Index
   Indirect get data from anywhere, thouhg Index can only reach 256 bytes
   CRUX
   1 - Indirect address must be in ZERO-PAGE 2 bytes
   2 - Y-reg will be used to form the final address together with the Indirect address real address
   Ex) LDA($C0), Y
     
        $00C0 = $11 (Byte 1) 
    	$00C1 = $22 (Byte 2)
    	Y-reg = 3
    	
    	$00C0 -> $00C1 "Low byte first" => $2211 is the address
    	Then add Y-reg value 3 to that =>  $2214
    
   Example usage: Manipulate computer screen
   We use the Y register to scan throug 256 bytes of data chunks, then we change the indirect address
   to point some where else and scan 256 bytes again...

   THE GREAT ZERO PAGE HUNT

   At 10) Indirect Indexed Mode

   1 - Indirect address must be in ZERO-PAGE 2 bytes
       Which means we must have 2 bytes available in zero-page for each indirect address we want to use.
       How to find zero-pages?
       Look for unused locations.
             - They are at $00FC to $00FF => C,D,E,F => 4 locations, that give us 2 indirect addresses in zero-page
             - In a mem map I read it is actually $00FB - $00Fe
       Look in "memory maps" designed as
             - "Work areas"
	     - "utility pointers"

11) Indexed, Indirect Mode
   Ex) LDA($C0, X)
   Indexing takes place first, contents of X-reg are added to the indirect address.
   When to use?
   
###########################
## Questions and Projects #
###########################

MLM = Machine Language Monitor
Supermon by Jim Butterfield => "MLM generator"
Instructions:

	R => Display / Change registers
	M => Display / Change memory
	S => Save memory to disk or tape
	L => Load from disk or tape
	G => Go to an machine language program
	X => Exit to basic
	A => Assemble
	D => Disassemble
	F => Fill memory with fixed contents
	H => Hunts for a memory pattern
	T => Transfers a block of memory to a new location
	
Project / Task : "Screen Manipulation"

   A (0,0)  => $0288 => $0400 start of screen mem
   B (0,5)  =>          $0404 offest by 4 (skip 4 first blocks, start at position 5)
   C (0,18) => End of first line
POS 1 2 3 4 5 6 7 8 9 10              18
    A       B = = = = = = = = = = = = C
    0       |          10             |     20                  30                40 
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
0  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
1  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
2  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
3  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
4  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
5  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
6  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
7  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
8  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
9  |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
10 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
11 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
12 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
13 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
14 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
15 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
16 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
17 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
18 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
19 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
20 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
21 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
22 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
23 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|    
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
24 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|
   |-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
25 |0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|0|1|2|3|4|5|6|7|8|9|

40 screen columns => 20 + 20 => HEX $14 + $14
                             => HEX $1F(31) + $09
		             => HEX $28
		      
   A 033C LDA #$28  => Load value decimal 40 into A-reg, representing 40 columns screen, "Line length"
   A 033E LDX $0288 => Screen mem c64 starts at what value exist at address $0288
                       According to memory maps of the Commodore 64 the address $0288 contains
		       *************************************************************************
		       * High byte of pointer to screen memory for screen input/output.        *
		       * Default: $04, $0400, 1024.                                            *
		       *************************************************************************
   A 0341 STA $03A0 => Save value in A-reg (#$28 dec 40) at mem location $03A0
   A 0344 STX $BC   => Save value in X-reg (whats at pos $0288) at zero page $00BC
                       We are using "zero page addressing" see 5), All addresses from $0000 to $00FF
                       Why at a zero page?
		       We are going to use indirect address, and that needs 2 bytes at a zero-page, see 10)
   A 0346 LDA #$00  => Here comes byte number 2s value $00
   A 0348 STA $BB   => $BB ===> LOW  BYTE = $00
                       $BC ===> HIGH BYTE = $04
		       Remember low byte first, stored in memory in C64
		       ex) "LDA $0288" => in mem "AE 88 02" lowbyte 88 highbyte 02
                       ex) "STA $03A0" => in mem "8D A0 03" lowbyte A0 highbyte 03
		       $BB = $00   (Byte 1) LOW  BYTE,               $00 => bin 0000 0000
		       $BC = $0288 (Byte 2) HIGH BYTE, at $0288 is a $04 => bin 0000 0100
		       RESULT $BB $BC
		              00   04
			     $0400 => start of screen memory YEHAAA
    A 034A LDX #$00 => X-reg will be our line counter. We start at line 0.
    A 034C LDY #$04 => Y-reg point at the start of the line, we want to start at possition 5
                       Why? Because there is a frame/padding around the prompt of the C64 of 4 positions!?
    A 034E LDA ($BB), Y => Indirect Indexed addressing
                           Start at $BB   + Y
			   Start at $0400 + 4
			   Start at $0404
			   So A-reg will be filled whats at position $0404 in memory.
    A 0350 CMP #$20 => We do not want to take action when character SPACE is found.
                       ASCII for SPACE is 32 which in hex is $20
                       CMP uses value in A-reg to compare with $20
    A 0352 BEQ $0356 => If it is a SPACE skip next operation at address $0354
    A 0354 EOR #$80  => Exclusive OR on A-reg with "mask" $80 bin 1000 0000 dec 128+0+0+0 + 0+0+0+0 = 128 
                        - - - -
                        | EOR | 1 => Flip bit, 0 => Keep Origin
                        - - - -
                        A-Reg	Mask	Mask Meaning	Result
                        0	0	Keep origin	0
                        1	0	Keep origin	1
                        0	1	Flip Bit	1
                        1	1	Flip Bit	0
			
			If A-reg is "A"/ASCII 65/hex $41 bin 0100 0001 dec 0+64+0+0 + 0+0+0+1 = 65
			    $41 : 0100 0001 : dec  65
                        EOR $80 : 1000 0000 : dec 128
			- - - - - - - - - - - - - - - -
			    $C1 : 1100 0001 : dec 193 = 128+64+1
			    
			We are "FLIPPING" the highest bit of the value of the screen.
   A 0356 STA($BB), Y => Indirect Index addressing when storing A-reg value
                         Store value $C1 (prev $41) at the same screen position $0404 that we previously read from.
			 Now we have done our magic to one screen position, some more to go!!!
   A 0358 INY        => Increment Y with 1 (if y was 4 y is now 5)
   A 0359 CPY $#12   => Compare Y-reg with value #$12 bin 0001 0010 dec 16+2 = 18
                        Y will be incremented from 4 to 18
			Y=4   Y=5   Y=6   Y=7   Y=8   Y=9   Y=10  Y=11  Y=12  Y=13  Y=14  Y=15  Y=16  Y=17  Y=18
			1     2     3     4     5     6     7     8     9     10    11    12    13    14    SKIP
			$0404,$0405,$0406,$0407,$0408,$0409,$040A,$040B,$040C,$040D,$040E,$040F,$0410,$0411,$0412
   A 035B BCC $034E  => BCC = less than => Y < 18 => Branch if Y is less than 18
                        That is branch to the code that uses indirect addressing for reading the next screen pos into A-reg
			So branch if we have read less than 14 screen positions and EOR their content.
			Each line we have decided is 14 positions, now continue with NEXT LINE
   A 035D CLC        => Carry, C-flag only affected by comparison, arithmetic (I think...)
                        So here we clear it to not affect future Branching instrucitons or other stuff I guess?
			Other stuff => Instructions that look at the Carry flag.
   A 035E LDA $BB    => Load the zero page address $BB which contain value #$00 into A-reg
   A 0360 ADC $03A0  => Addition in A-reg, Add x number of columns (we stored the value dec 40 into $03A0)
                          $BB   => $00 => dec  0
			+ $03A0 => $28 => dec 40
			- - - - - - - 
			           $28
   A 0363 STA $BB    => Store the new value $40 into zero page $BB
   A 0365 LDA $BC    => Load the zero page address $BC which contains value $04 into A-reg
   A 0367 ADC #$00   => We do this addition because a Carry flag migh have been set in the addition on $BB
                        We want that Carry to be passed on to $BC if that was the case (if $BB became greater than $FF)
   A 0369 STA $BC    => Store back the possibly larger value into $BC again
                        So here we have moved on to another place in screen memory of the C64...
   A 036B INX        => We had choosen X-reg to be our counter for how many lines we had read/altered
                        So lets increment X-reg to "next line" first time it will be set to $01 unt so weiter...
   A 036C CPX #$0E   => hex $0E dec 14 bin 0000 1110
                        Check to see hos X-reg is compared to 14 (14 lines)
   A 036E BNE $034C  => BNE : != : Branch if two BYTES are NOT EQUAL
                        Branch to start of program if we have not yet read line 14
			When we have read line 14 the next address will be read
   A 0370 RTS        => We are done return to invoker
   
PRESS X to exit to Basic from the monitor   
   
So what does the program do? It goes throug 14 lines on the screen
Each line has 40 chars/positions, in our program we affect position 5 to 18 that is 14 chars/positions.
Each of those line positions we do a EOR "mask" $80 
That does what? => Alter the background color...

Run program in BASIC

100 FOR J=1 TO 10  // Run our program 10 times
110 SYS 828        // Invoke program that starts at address dec 828 hex $033C
120 FOR K=1 TO 200 // Do a loop that does nothing 200 times to slow things down
130 NEXT K,J       // Run our program one more time

Type "RUN" to start the program

This will run our program sevral times and alter the background color on 14 lines that each are 14 chars.

#############
# CHAPTER 6 #
#############

Linking BASIC and Machine Language

STUFF
	C64: Address pointers $002B and $002C 
	     "zero pages": $2B and $2C 
	     Contains the addres for where BASIC is stored in memory => SOB
	     $002B: $01 (Low Byte First)
	     $002C: $08
	     Result: $0801
	     
	CASSETTE BUFFER: $033C-$03FB
	
BASIC	
	SOB: Start Of Basic
$0801	     $0801
	
	PROGRAM: A program you write will take memory in between SOB to EOB
		 for each line of code the distance grow between SOB and EOB
	
	EOB: End Of Basic
	     Some where after SOB, denotedt by 3 ZERO bytes $00, $00, $00
	     In my case in VICE
$0833	     $0833 $00
$0834	     $0834 $00
$0835	     $0835 $00
	
	SOV: Start Of Variables
	     Right after EOB, all your PROGRAM variables will take up memory here.
	     7 Byes per variable
	     Pointer addresses $002D and $002E contains the address for where SOV starts.
	     $002D: $36 (Low Byte First)
	     $002E: $08
$0836	     Result: $0836
	
	     SAVE: Basic SAVE command (direct mode)
	           Computer saves all memory from SOB => SOV, the whole program that is includding the 3 zeros.
	     LOAD: Basic LOAD command (direct mode)
	           Loads PROGRAM to mem between SOB => SOV
		    
	SOA: Start Of Arrays
	     Arrays created by BASIC DIM command or default...
	     Pointer addresses $002F and $0030 
	     $002F: $44 (Low Byte First)
	     $0030: $08 
$0844	     Result: $0844 in my setup using VICE
	     
	EOA: End Of Arrays
	     Pointer addresses $0031 and $0032 
	     $0031: $44 (Low Byte First)
	     $0032: $08 
$0844	     Result $0844 in my setup using VICE (cause currently no arrays exist, same values as SOA)
	     
	FREE: Free mem... "Above EOA" will be eaten by strings... do not put your ML program here.
	
        BOS: Bottom Of Strings
	     Last dynamic string that has been created
	     Strings created takes up FREE mem, that is BOS grows TOWARDS EOA
	     Pointer Addresses: $0033 and $0034
	     $0033: $19 (Low Byte First)
	     $0034: $95 
$9519	     Result: $9519 in my setup using VICE (If no BASIC strings, the address will be the same as for TOM)
	     
        TOM: Top Of Memory (EOB End Of Basic area)
	     One location beyond last available byte to BASIC, could be like $A000
$9519	     Pointer Addresses: $0037 and $0038
             $0037: $19 (Low Byte First)
	     $0038: $95 
	     Result: $9519 in my VICE setup, (close to A000...)
	     
Where to put Your ML program?

   A) $033C-$03FB: Cassette Buffer / Datasette buffer (192 bytes).
   B) Move TOM pointer closer to BOS/EOA, and use the freed memory.
   C) Move SOV pointer closer to SOA, use mem between SOB and new SOV
      OBS in B anc C, after moving pointers, return to basic and run CLR
      CLR => variable pointers will "allign" with the moved ones.
   D) 4K of RAM at $C000 to $CFFF, 49152 to 53247. Popular place may br used by other programs.
   E) REMOVE BASIC
      $0801 to $CFFF
      2049 to 53247 => 51198
      51198 / 1024 = 50K of free RAM
      Free ram by typing => POKE 1,54 AKA (LDA #$36, STA $01) => $36 = 54 dec
      Restore            => POKE 1,55 AKA (LDA #$37, STA $01) => $37 = 55 dec
   F) Not so popular methond in Commodore machines
      F1) Move SOB ($0801) to new address
      F2) Store a 0 in the position before SOB, (before the new SOB address that is)
      F3) Type the BASIC command "NEW" to allign pointers... 
          => Pointers like SOB SOV EOA TOM will be re calculated.
    
SOV - (S)tart (O)f (V)ariables

   - Basic variables values are written here
   - Basic command "SAVE" saves from SOB till SOV
   - Basic command "LOAD" ... load prg into mem, set SOV to after end of the loaded prg !!!
   - SOV is moved when more mem is required by BASIC
   
***Question: What happens if program is stored in Cassette Buffer??? $033C-$03FB
   Answer: SOV will be set to be before BASIC starts when a "DIRECT" (see later...) BASIC LOAD is done...
   
   BASIC LOAD => Oh no! using program, vars will be written in SOV, sooner or later write over BASIC it self.
   BASIC SAVE => Oh no! SAVE start at SOB till SOV
                 Basic will save program from $0801 -> $FFFF -> $0000 -> Cassette buffer $033C-$03FB
   BASIC "Edit code" => Oh no! Basic moves mem starting at change point, until it reaches SOV, all mem is disaster.
   
***Question: What happens if program is stored in high memory? 
             B) Moving TOM closer to  BOS/EOA, and use the freed memory.
	     D) Using mem at 4K of RAM at $C000 to $CFFF
	     
   Answer B) "Direct" BASIC LOAD, SOV affected! SOV will be positiond directly after loaded program.
             No room for variables, we will almost directly get OUT OF MEMORY
	     
   Answer D) "Direct" BASIC LOAD, SOV affected! SOV will be positiond directly after loaded program.
             No room for variables, we will almost directly get OUT OF MEMORY
	     
   In both B & D the SOV pointer will be a very high mem address...
   
   	Solution: 
		
		1) FIRST:  BASIC LOAD, machine language program into "High mem" (B/D) => Bad placed SOV pointer
		2) SECOND: BASIC LOAD, basic program, this second BASIC LOAD          => Will fix SOV pointer
		3) THIRD:  ???? FIX TOM pointer and command NEW between the two loads.... 
		   quote book: "you can not even give the next LOAD command if you are totally out of mem"
		   One can fix pointer by using the MLM...
		   M 002B 003A => list all BASIC pointers....
		   
***Question: Load ml program after EOB the three 0 0 0?
             Then move the SOV to a higher memory address?
   Answer: Will work IF
           1) BASIC LOAD the Basic program first => SOV at correct place
	   2) BASIC LOAD the mlm program into after EOB => SOV will move and be placed after that mlm program
	      which is ok. We can now BASIC SAVE will work it will save borh programs...
	      OBS one slight problem, we cannot change the BASIC program in 1)...
	      Because if we do that the mlm program will be moved in memory, and our SYS command for loading
	      the mlm program will point to the wrong address =)
	   
MLM = Machine Language Monitor
Supermon by Jim Butterfield => "MLM generator"
Instructions:

	R => Display / Change registers
	M => Display / Change memory
	S => Save memory to disk or tape
	L => Load from disk or tape
	G => Go to an machine language program
	X => Exit to basic
	A => Assemble
	D => Disassemble
	F => Fill memory with fixed contents
	H => Hunts for a memory pattern
	T => Transfers a block of memory to a new location
	
MLM - SAVE
 
    S "NaMeOfPrOgRaM",format,memStart,memEnd
    
    EX) Save to tape
        S "MyBestestPrgr",01,033C,0361
	Save program with name "MyBestestPrgr" using TAPE format (01), save data from $033C to $0361
 
    EX) Save to disk
        S "0:MyBestestPrgr",08,033C,0361
	hmmm??? 08 is format but what is the 0: in the program name?
	
MLM - LOAD
    
    - Load program without change the BASIC - SOV
    - L "NaMeOfPrOgRaM",01
	
BASIC - LOAD
 
    The Basic LOAD command changes the SOV when it is given as a DIRECT command in BASIC prompt.
    When LOAD command is used from within a BASIC program SOV is not changed!!!
    
    - DIRECT command: LOAD "NaMeOfPrOgRaM",8,1
    - PROGRAMMED command:  (for loading a machine language program, not loading another BASIC program)
    	* Chaining => 
    		A) No pointers affected, no vars will be lost
		B) When a BASIC program executes its lines of code, it then when it sees a LOAD it executes it...
		   Then one think that it would go to the line of code after LOAD, but NAH...
		   After LOAD is executed it returns to the first line of code in the BASIC progam...
		   A for ever loop is created...
		   
		   EX solution for this "bug" is
		   100 IF A=! GOTO 130
		   110 A=!
		   120 LOAD"NaMeOfPrOgRaM",8,1 (this will cause a jump to line 100)
		   130 the rest of the code

BASIC commands

   NEW 
      The BASIC command NEW releases the whole BASIC RAM and the stack of the C64.
      This way, BASIC program that eventually was stored in the memory will be deleted.
      
BASIC Variables

   Names of vars can be include the chars A-Z and the numbers 0-9
   First char of a variable name must be a letter.
   Variable names can only consist of 2 chars! hmmm is it true?

   - 7 bytes
   - BYTE 1,2 the variable name
   - BYTE 3,4,5,6,7 value or definition
   - Type is a part of the name
   
   Ex a) Float : variable name "AB"  (Ascii code $41, $42) 0100 0001, 0100 0010
   Ex b) Integr: variable name "AB%" (Ascii code $C1, $C2) 1100 0001, 1100 0010 (diff highest bit is set to 1 in both)
   Ex c) String: variable name "AB$" (Ascii code $41, $C2) 0100 0001, 1100 0010 (diff highest bit is set to 1 in second)
   Ex d) Function definition: variable name DEF FNA (...) TODO...
   
   Float: var name "AB"
   
	BYTE 1: Name byte 1
	BYTE 2: Name byte 2
	BYTE 3: ... Value is hidden deep in these 3 bytes... hard to see with the bare eye
	BYTE 4: ... Value is hidden deep in these 3 bytes...
	BYTE 5: ... Value is hidden deep in these 3 bytes...
	Locate SOV => Pointer addresses $002D and $002E => M 2D 2E => $03 $08 => SOV = $0803
	EX 1) 
	   Create a new BASIC variable
	   NEW => restore pointers and so on...
	   A=5
	   Check mem where SOV starts => M 0803
	   BYTE: 1  2  3  4  5  6  7
	   0803: 41 00 83 20 00 00 00
	   BYTE 1: Ascii Hex value for "A", 0100 0001, $41
	   BYTE 2: Ascii Hex value for "NOTHING", 0000 0000, $00 (We only used one char as variable name this time)
	EX 2) 
	   NEW
	   AB=5
	   BYTE: 1  2  3  4  5  6  7
	   0803: 41 42 83 20 00 00 00
	   BYTE 1: Ascii Hex value for "A", 0100 0001, $41
	   BYTE 2: Ascii Hex value for "B", 0100 0010, $42
	   
   Integer: var name "AB%", Integers make use of "%" to denote that the var is an integer,
            crux: And when using integers as vars, the "highbit" of the variable name bytes is set to 1.
   	BYTE 1: Name byte 1
	BYTE 2: Name byte 2
	BYTE 3: Value 256 - 32767
	BYTE 4: Value 0-256
	BYTE 5: ...
	
	EX 1)
	   NEW
           A%=5
	   BYTE: 1  2  3  4  5  6  7
	   0803: C1 80 00 05 00 00 00
	   BYTE 1: Ascii Hex value for "A" with the HIGH BIT set to 1
	   BYTE 2: Ascii Hex value for "NOTHING", 0, ZERO, 0000 0000, with HIGH BIT set to 1 => 1000 0000 => $80
	   BYTE 3: value is smaler than 256 so nothing here
	   BYTE 4: value is 5
	   BYTE 5: ...
	   
	EX 2)
	   NEW
	   AB%=5
	   BYTE: 1  2  3  4  5  6  7
	   0803: C1 C2 00 05 00 00 00
	   BYTE 1: Ascii Hex value for "A", 0100 0001, $41 with the HIGH BIT set to 1 = 1100 0001, $C1
	   BYTE 2: Ascii Hex value for "B", 0100 0010, $42 with the HIGH BIT set to 1 = 1100 0010, $C2
	   BYTE 3: value is smaler than 256 so nothing here
	   BYTE 4: value is 5
	   BYTE 5: ...

	EX 3)
	   NEW
	   AB%=32767 (highest possible possitive number in BASIC)
	   BYTE: 1  2  3  4  5  6  7
	   0803: C1 C2 7F FF 00 00 00
	   BYTE 1: Ascii Hex value for "A", 0100 0001, $41 with the HIGH BIT set to 1 = 1100 0001, $C1
	   BYTE 2: Ascii Hex value for "B", 0100 0010, $42 with the HIGH BIT set to 1 = 1100 0010, $C2
	   BYTE 3: value is larger than 255 => $7F = 0111 1111 (the highest bit is used for signed numbers in BASIC)
	   BYTE 4: value is 255 => $FF
	   BYTE 5: ...
	   
	EX 4)
	   NEW
	   AB%=-32768 (lowest possible value)
	   AB%=-32767 (lowest possible value + 1)
	   BYTE: 1  2  3  4  5  6  7
	   -32768 0803: C1 C2 80 00 00 00 00
	   -32767 0803: C1 C2 80 01 00 00 00
	       -2 0803: C1 C2 FF FE 00 00 00
	       -1 0803: C1 C2 FF FF 00 00 00
	        0 0803: C1 C2 00 00 00 00 00
		1 0803: C1 C2 00 01 00 00 00
	   So for -32768     
	   BYTE 1: Ascii Hex value for "A", 0100 0001, $41 with the HIGH BIT set to 1 = 1100 0001, $C1
	   BYTE 2: Ascii Hex value for "B", 0100 0010, $42 with the HIGH BIT set to 1 = 1100 0010, $C2
	   BYTE 3: $80, 1000 0000,

	   
   String: var name "AB$"
      	BYTE 1: Length of string
	BYTE 2: Address
	BYTE 3: Address
	BYTE 4: N/A
	BYTE 5: N/A
	
Exchanging Data: Basic and Machine Language

   - BASIC PEEK and POOK command
   - BASIC variables are stored in specific memory location, a machine language program can read/write them.
       
       * Search for BASIC variable NAME Integer AB% / Float "AB" /  String "AB$"
       
       * First BASIC variable starts at SOV
       
            Pointer addresses $002D and $002E contains the address for where SOV starts.
	    $002D: $36 (Low Byte First)
	    $002E: $08
	    Result: $0836 is the addres of SOV in this ex case.
         
       * Store SOV $002D and $002E as an Indirect Address with Index. (SOV may vary!!!)
       
         NOTE !!!! This is not a functional code, it is just a "skeleton" of how one might do it...
       
         EX) LDY $#00     => Y-reg will contain the hex value $00 bin 0000 0000 dec 0
             loop: How to label??? maybe learnt later on in book?
	     LDA ($2D), Y => A-reg (Accumulator)  will be used with Indirect Indexed addressing
	                     CRUX: In Indirect address mode, ZERO-PAGEs must be used!!!
			           Fortunately SOV is stored in 2 zero page addresses following each other
				   Also the LOW BYTE is stored first YES!!!
	                           SOV Low Byte : $2D : $002D (at a ZERO page)
			           SOV High Byte: $2E : $002E (at a ZERO page)
			           => Leads to that it is ok to use SOV pointer in indrirect index mode
			     
			     Result: The resulting Address where the real data can be found
			             => HIGH BYTE  - LOW BYTE
				     => $2E        - $2D
				     => $14        - $62
				     => $1462 + Y-reg
				     => $1462 + $#00
				     => $1462
				     
                             We search for a integer variable named "AB%"
			     "AB%" (Ascii code $C1, $C2) 1100 0001, 1100 0010
			     A BASIC variable is 7 bytes long.
			     We want to find this:
			     BYTE 1: Ascii Hex value for "A", 0100 0001, $41 with the HIGH BIT set to 1 = 1100 0001, $C1
	                     BYTE 2: Ascii Hex value for "B", 0100 0010, $42 with the HIGH BIT set to 1 = 1100 0010, $C2
			     
			     At address $1462 the 1st of 7 bytes is located.
		CMP $C1	     We want A-reg it to be $C1
		INY          Prepare Y-reg to check for second char "B" in the variable name that is stored in BYTE 2
		             Y-reg is incremented with 1
		BNE nextVar  If NOT Equal => 
		                    1) INY with 6 (next variable starts there) 
				    2) restart loop
	        nextVar: 
		
		<TODO>	     If     Equal => INY with 1 to get next variable name (if it consist of 2 chars...)
		<TODO>	     CHECK to se that we have not reached SOA Start Of Arrays
			     Because if so we did not find our variable.
		CMP $C2      Compare if the second char "B" matches
		<TODO>       If NOT Equal => INY with 7 (next variable starts there) restart loop 
		<TODO>	     If     Equal => I we have a MATCH yehaaaaa
		<TODO>	     CHECK to se that we have not reached SOA Start Of Arrays
			     Because if so we did not find our variable.
  
#############
##  Project #
#############

Basic program inoke MLP to multiply by 10

Place MLP behind EOB, (E)nd (O)f (B)asic

1 Guess SIZE of our BASIC program

just typed it in, it worked...

###########################
## Questions and  Project #
###########################
 
* Write several BASIC programs that invokes MLPs
* ..
* ...
		   
#############
# CHAPTER 7 #
#############

Stack, USR, Interrupt and Wedge

Temporary Storage: The Stack

 * push to stack: PHA push A-reg value to stack
 * pull from stack: PLA pull value from stack into A-reg
 * LIFO
 * SP Stack Pointer
 * $01FF - $0100
 * If SP is $F8 next item in stack will be put at $01F8
 * Next time after we have pushed it will be $F7
 * SP vale below $40 signals trouble  =>BASIC may signal "OUT OF MEMORY"
 
 * PHP / PLP
   Push SR flags to stack / Pull SR flags from stack and put them into SR
   Push the SR flags to stack: Nice to do when we want to chech several comparisons later on
 
 * JSR / RTS
   JSR: Jump To Subroutine => puts return address onto stack.
   RTS: Picks the return address from the stack
   Quirk: JSR puts return address -1 as 2 Bytes onto the stack, HIGH BYTE firstly, then the LOW BYTE
          Ex) $0352: JSR $033C
	             Next instruction is the one following JSR, In this case $0355
		     Quirk: $0355 - 1 = $0354
		     a) PUSH $03 to stack
		     b) PUSH $54 to stack
		     Then the routine at $033C executes and reaches RTS
		     Which pulls first $54 the LOW BYTE then $03 the HIGH BYTE
		     Quirk: $0354 + 1 = $0355 => The return address to start execute at
              $0355: The return address
